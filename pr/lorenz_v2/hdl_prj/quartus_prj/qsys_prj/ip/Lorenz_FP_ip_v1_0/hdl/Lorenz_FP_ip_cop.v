// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\lorenz_model\Lorenz_FP_ip_cop.v
// Created: 2019-05-03 13:00:14
// 
// Generated by MATLAB 9.4 and HDL Coder 3.12
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Lorenz_FP_ip_cop
// Source Path: Lorenz_FP_ip/Lorenz_FP_ip_cop
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Lorenz_FP_ip_cop
          (clk,
           reset,
           in_strobe,
           cop_enable,
           out_ready,
           dut_enable,
           reg_strobe);


  input   clk;
  input   reset;
  input   in_strobe;  // ufix1
  input   cop_enable;  // ufix1
  output  out_ready;  // ufix1
  output  dut_enable;  // ufix1
  output  reg_strobe;  // ufix1


  wire enb;
  reg [7:0] cp_controller_cpstate;  // uint8
  reg  cp_controller_clkcnt;  // ufix1
  reg [7:0] cp_controller_cpstate_next;  // uint8
  reg  cp_controller_clkcnt_next;  // ufix1
  reg  out_ready_1;  // ufix1
  reg  dut_enable_1;  // ufix1
  reg  reg_strobe_1;  // ufix1
  reg  cp_controller_clkcnt_temp;  // ufix1
  reg [1:0] cp_controller_add_temp;  // ufix2
  reg [1:0] cp_controller_t_0_0;  // ufix2


  assign enb = cop_enable;

  always @(posedge clk or posedge reset)
    begin : cp_controller_process
      if (reset == 1'b1) begin
        cp_controller_cpstate <= 8'd0;
        cp_controller_clkcnt <= 1'b0;
      end
      else begin
        if (enb) begin
          cp_controller_cpstate <= cp_controller_cpstate_next;
          cp_controller_clkcnt <= cp_controller_clkcnt_next;
        end
      end
    end

  always @(cp_controller_cpstate, cp_controller_clkcnt, in_strobe) begin
    cp_controller_cpstate_next = cp_controller_cpstate;
    case ( cp_controller_cpstate)
      8'd0 :
        begin
          out_ready_1 = 1'b1;
          dut_enable_1 = 1'b0;
          reg_strobe_1 = 1'b0;
          cp_controller_clkcnt_temp = 1'b0;
          if (in_strobe != 1'b0) begin
            cp_controller_cpstate_next = 8'd1;
          end
          else begin
            cp_controller_cpstate_next = 8'd0;
          end
        end
      8'd1 :
        begin
          out_ready_1 = 1'b0;
          dut_enable_1 = 1'b1;
          reg_strobe_1 = 1'b0;
          cp_controller_t_0_0 = {1'b0, cp_controller_clkcnt};
          cp_controller_add_temp = cp_controller_t_0_0 + 2'b01;
          cp_controller_clkcnt_temp = cp_controller_add_temp[0];
          if (cp_controller_clkcnt_temp == 1'b1) begin
            cp_controller_cpstate_next = 8'd2;
          end
          else begin
            cp_controller_cpstate_next = 8'd1;
          end
        end
      8'd2 :
        begin
          out_ready_1 = 1'b0;
          dut_enable_1 = 1'b0;
          reg_strobe_1 = 1'b1;
          cp_controller_clkcnt_temp = 1'b0;
          cp_controller_cpstate_next = 8'd0;
        end
      default :
        begin
          out_ready_1 = 1'b0;
          dut_enable_1 = 1'b0;
          reg_strobe_1 = 1'b0;
          cp_controller_clkcnt_temp = 1'b0;
          cp_controller_cpstate_next = 8'd0;
        end
    endcase
    cp_controller_clkcnt_next = cp_controller_clkcnt_temp;
  end



  assign out_ready = out_ready_1;

  assign dut_enable = dut_enable_1;

  assign reg_strobe = reg_strobe_1;

endmodule  // Lorenz_FP_ip_cop

