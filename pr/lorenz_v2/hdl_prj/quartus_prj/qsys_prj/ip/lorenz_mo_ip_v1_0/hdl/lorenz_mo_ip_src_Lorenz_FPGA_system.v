// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\lorenz_model\lorenz_mo_ip_src_Lorenz_FPGA_system.v
// Created: 2019-04-22 12:39:55
// 
// Generated by MATLAB 9.4 and HDL Coder 3.12
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 0.001
// Target subsystem base rate: 0.001
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        0.001
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// x                             ce_out        0.001
// y                             ce_out        0.001
// z                             ce_out        0.001
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: lorenz_mo_ip_src_Lorenz_FPGA_system
// Source Path: lorenz_model/Lorenz_FPGA_system
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module lorenz_mo_ip_src_Lorenz_FPGA_system
          (clk,
           reset,
           clk_enable,
           sigma,
           x0,
           rho,
           y0,
           beta,
           z0,
           dt,
           ce_out,
           x,
           y,
           z);


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [26:0] sigma;  // sfix27_En20
  input   signed [26:0] x0;  // sfix27_En20
  input   signed [26:0] rho;  // sfix27_En20
  input   signed [26:0] y0;  // sfix27_En20
  input   signed [26:0] beta;  // sfix27_En20
  input   signed [26:0] z0;  // sfix27_En20
  input   signed [26:0] dt;  // sfix27_En20
  output  ce_out;
  output  signed [26:0] x;  // sfix27_En20
  output  signed [26:0] y;  // sfix27_En20
  output  signed [26:0] z;  // sfix27_En20


  wire enb;
  wire Accumulator_reg_ctrl_const_out;
  reg  [0:2] delayMatch4_reg;  // ufix1 [3]
  wire [0:2] delayMatch4_reg_next;  // ufix1 [3]
  wire Accumulator_reg_ctrl_delay_out;
  wire signed [26:0] Accumulator_reg_Initial_Val_out;  // sfix27_En20
  reg signed [26:0] sigma_1;  // sfix27_En20
  reg signed [26:0] dt_1;  // sfix27_En20
  wire signed [53:0] sigma_dt_mul_temp;  // sfix54_En40
  wire signed [26:0] sigma_dt_out1;  // sfix27_En20
  reg signed [26:0] sigma_dt_out1_1;  // sfix27_En20
  wire Accumulator1_reg_ctrl_const_out;
  reg  [0:2] delayMatch3_reg;  // ufix1 [3]
  wire [0:2] delayMatch3_reg_next;  // ufix1 [3]
  wire Accumulator1_reg_ctrl_delay_out;
  wire signed [26:0] Accumulator1_reg_Initial_Val_out;  // sfix27_En20
  reg signed [26:0] dt_2;  // sfix27_En20
  reg signed [26:0] delayMatch2_reg [0:1];  // sfix27 [2]
  wire signed [26:0] delayMatch2_reg_next [0:1];  // sfix27_En20 [2]
  wire signed [26:0] rho_1;  // sfix27_En20
  wire Accumulator2_reg_ctrl_const_out;
  reg  [0:2] delayMatch1_reg;  // ufix1 [3]
  wire [0:2] delayMatch1_reg_next;  // ufix1 [3]
  wire Accumulator2_reg_ctrl_delay_out;
  wire signed [26:0] Accumulator2_reg_Initial_Val_out;  // sfix27_En20
  reg signed [26:0] beta_1;  // sfix27_En20
  wire signed [53:0] beta_dt_mul_temp;  // sfix54_En40
  wire signed [26:0] beta_dt_out1;  // sfix27_En20
  reg signed [26:0] beta_dt_out1_1;  // sfix27_En20
  wire signed [26:0] Accumulator1_x_reg;  // sfix27_En20
  wire signed [53:0] y_dt_mul_temp;  // sfix54_En40
  wire signed [26:0] y_dt_out1;  // sfix27_En20
  wire signed [26:0] Accumulator2_x_reg;  // sfix27_En20
  wire signed [53:0] Product3_mul_temp;  // sfix54_En40
  wire signed [26:0] Product3_out1;  // sfix27_En20
  wire signed [26:0] x_dt_out1;  // sfix27_En20
  wire signed [53:0] Product1_mul_temp;  // sfix54_En40
  wire signed [26:0] Product1_out1;  // sfix27_En20
  wire signed [26:0] Sum3_out1;  // sfix27_En20
  wire signed [26:0] Accumulator2_u_add;  // sfix27_En20
  reg signed [26:0] Accumulator2_reg_out;  // sfix27_En20
  wire signed [26:0] Sum1_out1;  // sfix27_En20
  wire signed [26:0] Accumulator_x_reg;  // sfix27_En20
  wire signed [53:0] x_dt_mul_temp;  // sfix54_En40
  wire signed [53:0] Product_mul_temp;  // sfix54_En40
  wire signed [26:0] Product_out1;  // sfix27_En20
  wire signed [26:0] Sum2_out1;  // sfix27_En20
  wire signed [26:0] Accumulator1_u_add;  // sfix27_En20
  reg signed [26:0] Accumulator1_reg_out;  // sfix27_En20
  wire signed [26:0] Sum_out1;  // sfix27_En20
  wire signed [53:0] Product2_mul_temp;  // sfix54_En40
  wire signed [26:0] Product2_out1;  // sfix27_En20
  wire signed [26:0] Accumulator_u_add;  // sfix27_En20
  reg signed [26:0] Accumulator_reg_out;  // sfix27_En20


  assign Accumulator_reg_ctrl_const_out = 1'b1;



  assign enb = clk_enable;

  always @(posedge clk or posedge reset)
    begin : delayMatch4_process
      if (reset == 1'b1) begin
        delayMatch4_reg[0] <= 1'b0;
        delayMatch4_reg[1] <= 1'b0;
        delayMatch4_reg[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch4_reg[0] <= delayMatch4_reg_next[0];
          delayMatch4_reg[1] <= delayMatch4_reg_next[1];
          delayMatch4_reg[2] <= delayMatch4_reg_next[2];
        end
      end
    end

  assign Accumulator_reg_ctrl_delay_out = delayMatch4_reg[2];
  assign delayMatch4_reg_next[0] = Accumulator_reg_ctrl_const_out;
  assign delayMatch4_reg_next[1] = delayMatch4_reg[0];
  assign delayMatch4_reg_next[2] = delayMatch4_reg[1];



  assign Accumulator_reg_Initial_Val_out = 27'sb111111100000000000000000000;



  always @(posedge clk or posedge reset)
    begin : HwModeRegister2_process
      if (reset == 1'b1) begin
        sigma_1 <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          sigma_1 <= sigma;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        dt_1 <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          dt_1 <= dt;
        end
      end
    end



  assign sigma_dt_mul_temp = sigma_1 * dt_1;
  assign sigma_dt_out1 = sigma_dt_mul_temp[46:20];



  always @(posedge clk or posedge reset)
    begin : PipelineRegister1_process
      if (reset == 1'b1) begin
        sigma_dt_out1_1 <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          sigma_dt_out1_1 <= sigma_dt_out1;
        end
      end
    end



  assign Accumulator1_reg_ctrl_const_out = 1'b1;



  always @(posedge clk or posedge reset)
    begin : delayMatch3_process
      if (reset == 1'b1) begin
        delayMatch3_reg[0] <= 1'b0;
        delayMatch3_reg[1] <= 1'b0;
        delayMatch3_reg[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch3_reg[0] <= delayMatch3_reg_next[0];
          delayMatch3_reg[1] <= delayMatch3_reg_next[1];
          delayMatch3_reg[2] <= delayMatch3_reg_next[2];
        end
      end
    end

  assign Accumulator1_reg_ctrl_delay_out = delayMatch3_reg[2];
  assign delayMatch3_reg_next[0] = Accumulator1_reg_ctrl_const_out;
  assign delayMatch3_reg_next[1] = delayMatch3_reg[0];
  assign delayMatch3_reg_next[2] = delayMatch3_reg[1];



  assign Accumulator1_reg_Initial_Val_out = 27'sb000000000011001100110011010;



  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        dt_2 <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          dt_2 <= dt_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : delayMatch2_process
      if (reset == 1'b1) begin
        delayMatch2_reg[0] <= 27'sb000000000000000000000000000;
        delayMatch2_reg[1] <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch2_reg[0] <= delayMatch2_reg_next[0];
          delayMatch2_reg[1] <= delayMatch2_reg_next[1];
        end
      end
    end

  assign rho_1 = delayMatch2_reg[1];
  assign delayMatch2_reg_next[0] = rho;
  assign delayMatch2_reg_next[1] = delayMatch2_reg[0];



  assign Accumulator2_reg_ctrl_const_out = 1'b1;



  always @(posedge clk or posedge reset)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        delayMatch1_reg[0] <= 1'b0;
        delayMatch1_reg[1] <= 1'b0;
        delayMatch1_reg[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
          delayMatch1_reg[2] <= delayMatch1_reg_next[2];
        end
      end
    end

  assign Accumulator2_reg_ctrl_delay_out = delayMatch1_reg[2];
  assign delayMatch1_reg_next[0] = Accumulator2_reg_ctrl_const_out;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];
  assign delayMatch1_reg_next[2] = delayMatch1_reg[1];



  assign Accumulator2_reg_Initial_Val_out = 27'sb001100100000000000000000000;



  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        beta_1 <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          beta_1 <= beta;
        end
      end
    end



  assign beta_dt_mul_temp = beta_1 * dt_1;
  assign beta_dt_out1 = beta_dt_mul_temp[46:20];



  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        beta_dt_out1_1 <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          beta_dt_out1_1 <= beta_dt_out1;
        end
      end
    end



  assign y_dt_mul_temp = Accumulator1_x_reg * dt_2;
  assign y_dt_out1 = y_dt_mul_temp[46:20];



  assign Product3_mul_temp = Accumulator2_x_reg * beta_dt_out1_1;
  assign Product3_out1 = Product3_mul_temp[46:20];



  assign Product1_mul_temp = x_dt_out1 * Accumulator1_x_reg;
  assign Product1_out1 = Product1_mul_temp[46:20];



  assign Sum3_out1 = Product1_out1 - Product3_out1;



  assign Accumulator2_u_add = Accumulator2_x_reg + Sum3_out1;



  always @(posedge clk or posedge reset)
    begin : Accumulator2_reg_process
      if (reset == 1'b1) begin
        Accumulator2_reg_out <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Accumulator2_reg_out <= Accumulator2_u_add;
        end
      end
    end



  assign Accumulator2_x_reg = (Accumulator2_reg_ctrl_delay_out == 1'b0 ? Accumulator2_reg_Initial_Val_out :
              Accumulator2_reg_out);



  assign Sum1_out1 = rho_1 - Accumulator2_x_reg;



  assign x_dt_mul_temp = Accumulator_x_reg * dt_2;
  assign x_dt_out1 = x_dt_mul_temp[46:20];



  assign Product_mul_temp = x_dt_out1 * Sum1_out1;
  assign Product_out1 = Product_mul_temp[46:20];



  assign Sum2_out1 = Product_out1 - y_dt_out1;



  assign Accumulator1_u_add = Accumulator1_x_reg + Sum2_out1;



  always @(posedge clk or posedge reset)
    begin : Accumulator1_reg_process
      if (reset == 1'b1) begin
        Accumulator1_reg_out <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Accumulator1_reg_out <= Accumulator1_u_add;
        end
      end
    end



  assign Accumulator1_x_reg = (Accumulator1_reg_ctrl_delay_out == 1'b0 ? Accumulator1_reg_Initial_Val_out :
              Accumulator1_reg_out);



  assign Sum_out1 = Accumulator1_x_reg - Accumulator_x_reg;



  assign Product2_mul_temp = sigma_dt_out1_1 * Sum_out1;
  assign Product2_out1 = Product2_mul_temp[46:20];



  assign Accumulator_u_add = Accumulator_x_reg + Product2_out1;



  always @(posedge clk or posedge reset)
    begin : Accumulator_reg_process
      if (reset == 1'b1) begin
        Accumulator_reg_out <= 27'sb000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Accumulator_reg_out <= Accumulator_u_add;
        end
      end
    end



  assign Accumulator_x_reg = (Accumulator_reg_ctrl_delay_out == 1'b0 ? Accumulator_reg_Initial_Val_out :
              Accumulator_reg_out);



  assign x = Accumulator_x_reg;

  assign y = Accumulator1_x_reg;

  assign z = Accumulator2_x_reg;

  assign ce_out = clk_enable;

endmodule  // lorenz_mo_ip_src_Lorenz_FPGA_system

